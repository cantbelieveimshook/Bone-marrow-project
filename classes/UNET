import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image, ImageDraw 
from numpy import asarray
from google.colab import drive
import torch
from torch import nn
from torch.utils.data import Dataset
import torchvision
import torchvision.transforms as transforms
import torch.nn.functional as F
from math import sqrt
import sklearn
from sklearn import cluster
from sklearn.cluster import KMeans
from sklearn.model_selection import train_test_split
from sklearn import preprocessing
import tensorflow as tf 
from tensorflow import keras
from keras import layers
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, Activation, ReLU
from tensorflow.keras.layers import BatchNormalization, Conv2DTranspose, Concatenate
from tensorflow.keras.models import Model, Sequential
import os
from os import listdir
import torch.optim as optim

# based on https://medium.com/analytics-vidhya/unet-implementation-in-pytorch-idiot-developer-da40d955f201

class conv_block(nn.Module):
    def __init__(self, in_layers, out_layers):
        super().__init__()
        self.conv1 = nn.Conv2d(in_layers, out_layers, 3, padding = 1) # modified, was originally 3, 6, 5. shrunk kernel size from 5 to 3.
        self.bn1 = nn.BatchNorm2d(out_layers)
        self.conv2 = nn.Conv2d(out_layers, out_layers, 3, padding = 1)
        self.bn2 = nn.BatchNorm2d(out_layers)

    def forward(self, x):
        x = F.relu(self.bn1(self.conv1(x)))
        x = F.relu(self.bn2(self.conv2(x)))
        return x


class encoder(nn.Module):
  def __init__(self, in_layers, out_layers):
    super().__init__()
    self.conv = conv_block(in_layers, out_layers)
    self.pool = nn.MaxPool2d((2, 2))
  
  def forward(self, inputs):
    x = self.conv(inputs)
    pool = self.pool(x)
    return x, pool

class decoder(nn.Module):
    def __init__(self, in_layers, out_layers):
        super().__init__()
        self.up = nn.ConvTranspose2d(in_layers, out_layers, kernel_size = 2, stride = 2, padding = 0)
        self.conv = conv_block(out_layers + out_layers, out_layers)
    
    def forward(self, inputs, skip):
        x = self.up(inputs)
        print(np.shape(x))
        x = torch.cat([x, skip], axis = 1)
        x = self.conv(x)
        return x

class Net(nn.Module):
  def __init__(self):
    super().__init__()
    self.e1 = encoder(3, 64)
    self.e2 = encoder(64, 128)
    self.e3 = encoder(128, 256)
    self.e4 = encoder(256, 512)
    
    self.b = conv_block(512, 1024)
    
    self.d1 = decoder(1024, 512)
    self.d2 = decoder(512, 256)
    self.d3 = decoder(256, 128)
    self.d4 = decoder(128, 64)
    
    self.outputs = nn.Conv2d(64, 1, kernel_size = 1, padding = 0)

  def forward(self, inputs):
    s1, p1 = self.e1(inputs)
    s2, p2 = self.e2(p1)
    s3, p3 = self.e3(p2)
    s4, p4 = self.e4(p3)
    
    b = self.b(p4)

    d1 = self.d1(b, s4)
    d2 = self.d2(d1, s3)
    d3 = self.d3(d2, s2)
    d4 = self.d4(d3, s1)

    outputs = self.outputs(d4)

    return outputs
